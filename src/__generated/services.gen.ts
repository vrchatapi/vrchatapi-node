// This file is auto-generated by @hey-api/openapi-ts

import { client, type Options } from '@hey-api/client-fetch';
import type { CheckUserExistsData, CheckUserExistsError, CheckUserExistsResponse, GetCurrentUserError, GetCurrentUserResponse, Verify2FaData, Verify2FaError, Verify2FaResponse, VerifyRecoveryCodeData, VerifyRecoveryCodeError, VerifyRecoveryCodeResponse, Verify2FaEmailCodeData, Verify2FaEmailCodeError, Verify2FaEmailCodeResponse, VerifyAuthTokenError, VerifyAuthTokenResponse, LogoutError, LogoutResponse, DeleteUserData, DeleteUserError, DeleteUserResponse, GetOwnAvatarData, GetOwnAvatarError, GetOwnAvatarResponse, SearchAvatarsData, SearchAvatarsError, SearchAvatarsResponse, CreateAvatarData, CreateAvatarError, CreateAvatarResponse, GetAvatarData, GetAvatarError, GetAvatarResponse, UpdateAvatarData, UpdateAvatarError, UpdateAvatarResponse, DeleteAvatarData, DeleteAvatarError, DeleteAvatarResponse, SelectAvatarData, SelectAvatarError, SelectAvatarResponse, SelectFallbackAvatarData, SelectFallbackAvatarError, SelectFallbackAvatarResponse, GetFavoritedAvatarsData, GetFavoritedAvatarsError, GetFavoritedAvatarsResponse, GetSteamTransactionsError, GetSteamTransactionsResponse, GetSteamTransactionData, GetSteamTransactionError, GetSteamTransactionResponse, GetCurrentSubscriptionsError, GetCurrentSubscriptionsResponse, GetSubscriptionsError, GetSubscriptionsResponse, GetLicenseGroupData, GetLicenseGroupError, GetLicenseGroupResponse, GetFavoritesData, GetFavoritesError, GetFavoritesResponse, AddFavoriteData, AddFavoriteError, AddFavoriteResponse, GetFavoriteData, GetFavoriteError, GetFavoriteResponse, RemoveFavoriteData, RemoveFavoriteError, RemoveFavoriteResponse, GetFavoriteGroupsData, GetFavoriteGroupsError, GetFavoriteGroupsResponse, GetFavoriteGroupData, GetFavoriteGroupError, GetFavoriteGroupResponse, UpdateFavoriteGroupData, UpdateFavoriteGroupError, UpdateFavoriteGroupResponse, ClearFavoriteGroupData, ClearFavoriteGroupError, ClearFavoriteGroupResponse, GetFilesData, GetFilesError, GetFilesResponse, CreateFileData, CreateFileError, CreateFileResponse, GetFileData, GetFileError, GetFileResponse, DeleteFileData, DeleteFileError, DeleteFileResponse, CreateFileVersionData, CreateFileVersionError, CreateFileVersionResponse, DownloadFileVersionData, DownloadFileVersionError, DownloadFileVersionResponse, DeleteFileVersionData, DeleteFileVersionError, DeleteFileVersionResponse, FinishFileDataUploadData, FinishFileDataUploadError, FinishFileDataUploadResponse, StartFileDataUploadData, StartFileDataUploadError, StartFileDataUploadResponse, GetFileDataUploadStatusData, GetFileDataUploadStatusError, GetFileDataUploadStatusResponse, GetFriendsData, GetFriendsError, GetFriendsResponse, FriendData, FriendError, FriendResponse, DeleteFriendRequestData, DeleteFriendRequestError, DeleteFriendRequestResponse, GetFriendStatusData, GetFriendStatusError, GetFriendStatusResponse, UnfriendData, UnfriendError, UnfriendResponse, SearchGroupsData, SearchGroupsError, SearchGroupsResponse, CreateGroupData, CreateGroupError, CreateGroupResponse, GetGroupData, GetGroupError, GetGroupResponse, UpdateGroupData, UpdateGroupError, UpdateGroupResponse, DeleteGroupData, DeleteGroupError, DeleteGroupResponse, GetGroupAnnouncementsData, GetGroupAnnouncementsError, GetGroupAnnouncementsResponse, CreateGroupAnnouncementData, CreateGroupAnnouncementError, CreateGroupAnnouncementResponse, DeleteGroupAnnouncementData, DeleteGroupAnnouncementError, DeleteGroupAnnouncementResponse, GetGroupAuditLogsData, GetGroupAuditLogsError, GetGroupAuditLogsResponse, GetGroupBansData, GetGroupBansError, GetGroupBansResponse, BanGroupMemberData, BanGroupMemberError, BanGroupMemberResponse, UnbanGroupMemberData, UnbanGroupMemberError, UnbanGroupMemberResponse, CreateGroupGalleryData, CreateGroupGalleryError, CreateGroupGalleryResponse, GetGroupGalleryImagesData, GetGroupGalleryImagesError, GetGroupGalleryImagesResponse, UpdateGroupGalleryData, UpdateGroupGalleryError, UpdateGroupGalleryResponse, DeleteGroupGalleryData, DeleteGroupGalleryError, DeleteGroupGalleryResponse, AddGroupGalleryImageData, AddGroupGalleryImageError, AddGroupGalleryImageResponse, DeleteGroupGalleryImageData, DeleteGroupGalleryImageError, DeleteGroupGalleryImageResponse, GetGroupInstancesData, GetGroupInstancesError, GetGroupInstancesResponse, GetGroupInvitesData, GetGroupInvitesError, GetGroupInvitesResponse, CreateGroupInviteData, CreateGroupInviteError, CreateGroupInviteResponse, DeleteGroupInviteData, DeleteGroupInviteError, DeleteGroupInviteResponse, JoinGroupData, JoinGroupError, JoinGroupResponse, LeaveGroupData, LeaveGroupError, LeaveGroupResponse, GetGroupMembersData, GetGroupMembersError, GetGroupMembersResponse, GetGroupMemberData, GetGroupMemberError, GetGroupMemberResponse, UpdateGroupMemberData, UpdateGroupMemberError, UpdateGroupMemberResponse, KickGroupMemberData, KickGroupMemberError, KickGroupMemberResponse, AddGroupMemberRoleData, AddGroupMemberRoleError, AddGroupMemberRoleResponse, RemoveGroupMemberRoleData, RemoveGroupMemberRoleError, RemoveGroupMemberRoleResponse, GetGroupPermissionsData, GetGroupPermissionsError, GetGroupPermissionsResponse, GetGroupPostData, GetGroupPostError, GetGroupPostResponse, AddGroupPostData, AddGroupPostError, AddGroupPostResponse, DeleteGroupPostData, DeleteGroupPostError, DeleteGroupPostResponse, UpdateGroupPostData, UpdateGroupPostError, UpdateGroupPostResponse, GetGroupRequestsData, GetGroupRequestsError, GetGroupRequestsResponse, CancelGroupRequestData, CancelGroupRequestError, CancelGroupRequestResponse, RespondGroupJoinRequestData, RespondGroupJoinRequestError, RespondGroupJoinRequestResponse, GetGroupRolesData, GetGroupRolesError, GetGroupRolesResponse, CreateGroupRoleData, CreateGroupRoleError, CreateGroupRoleResponse, UpdateGroupRoleData, UpdateGroupRoleError, UpdateGroupRoleResponse, DeleteGroupRoleData, DeleteGroupRoleError, DeleteGroupRoleResponse, InviteUserData, InviteUserError, InviteUserResponse, InviteMyselfToData, InviteMyselfToError, InviteMyselfToResponse, RequestInviteData, RequestInviteError, RequestInviteResponse, RespondInviteData, RespondInviteError, RespondInviteResponse, GetInviteMessagesData, GetInviteMessagesError, GetInviteMessagesResponse, GetInviteMessageData, GetInviteMessageError, GetInviteMessageResponse, UpdateInviteMessageData, UpdateInviteMessageError, UpdateInviteMessageResponse, ResetInviteMessageData, ResetInviteMessageError, ResetInviteMessageResponse, CreateInstanceData, CreateInstanceError, CreateInstanceResponse, GetInstanceData, GetInstanceError, GetInstanceResponse, CloseInstanceData, CloseInstanceError, CloseInstanceResponse, GetShortNameData, GetShortNameError, GetShortNameResponse, SendSelfInviteData, SendSelfInviteError, SendSelfInviteResponse, GetInstanceByShortNameData, GetInstanceByShortNameError, GetInstanceByShortNameResponse, GetNotificationsData, GetNotificationsError, GetNotificationsResponse, AcceptFriendRequestData, AcceptFriendRequestError, AcceptFriendRequestResponse, MarkNotificationAsReadData, MarkNotificationAsReadError, MarkNotificationAsReadResponse, DeleteNotificationData, DeleteNotificationError, DeleteNotificationResponse, ClearNotificationsError, ClearNotificationsResponse, GetAssignedPermissionsError, GetAssignedPermissionsResponse, GetPermissionData, GetPermissionError, GetPermissionResponse, GetPlayerModerationsData, GetPlayerModerationsError, GetPlayerModerationsResponse, ModerateUserData, ModerateUserError, ModerateUserResponse, ClearAllPlayerModerationsError, ClearAllPlayerModerationsResponse, GetPlayerModerationData, GetPlayerModerationError, GetPlayerModerationResponse, DeletePlayerModerationData, DeletePlayerModerationError, DeletePlayerModerationResponse, UnmoderateUserData, UnmoderateUserError, UnmoderateUserResponse, GetConfigError, GetConfigResponse, GetInfoPushData, GetInfoPushError, GetInfoPushResponse, GetCssData, GetCssError, GetCssResponse, GetJavaScriptData, GetJavaScriptError, GetJavaScriptResponse, GetHealthError, GetHealthResponse, GetCurrentOnlineUsersError, GetCurrentOnlineUsersResponse, GetSystemTimeError, GetSystemTimeResponse, SearchUsersData, SearchUsersError, SearchUsersResponse, GetUserByNameData, GetUserByNameError, GetUserByNameResponse, GetUserData, GetUserError, GetUserResponse, UpdateUserData, UpdateUserError, UpdateUserResponse, GetUserGroupsData, GetUserGroupsError, GetUserGroupsResponse, GetUserGroupRequestsData, GetUserGroupRequestsError, GetUserGroupRequestsResponse, GetUserRepresentedGroupData, GetUserRepresentedGroupError, GetUserRepresentedGroupResponse, SearchWorldsData, SearchWorldsError, SearchWorldsResponse, CreateWorldData, CreateWorldError, CreateWorldResponse, GetActiveWorldsData, GetActiveWorldsError, GetActiveWorldsResponse, GetFavoritedWorldsData, GetFavoritedWorldsError, GetFavoritedWorldsResponse, GetRecentWorldsData, GetRecentWorldsError, GetRecentWorldsResponse, GetWorldData, GetWorldError, GetWorldResponse, UpdateWorldData, UpdateWorldError, UpdateWorldResponse, DeleteWorldData, DeleteWorldError, DeleteWorldResponse, GetWorldMetadataData, GetWorldMetadataError, GetWorldMetadataResponse, GetWorldPublishStatusData, GetWorldPublishStatusError, GetWorldPublishStatusResponse, PublishWorldData, PublishWorldError, PublishWorldResponse, UnpublishWorldData, UnpublishWorldError, UnpublishWorldResponse, GetWorldInstanceData, GetWorldInstanceError, GetWorldInstanceResponse } from './types.gen';

/**
 * Check User Exists
 * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.
 *
 * It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
 */
export const checkUserExists = (options?: Options<CheckUserExistsData>) => { return (options?.client ?? client).get<CheckUserExistsResponse, CheckUserExistsError>({
    ...options,
    url: '/auth/exists'
}); };

/**
 * Login and/or Get Current User Info
 * This endpoint does the following two operations:
 * 1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.
 * 2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.
 *
 * The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.
 *
 * > base64(urlencode(username):urlencode(password))
 *
 * **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
 */
export const getCurrentUser = (options?: Options) => { return (options?.client ?? client).get<GetCurrentUserResponse, GetCurrentUserError>({
    ...options,
    url: '/auth/user'
}); };

/**
 * Verify 2FA code
 * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
 */
export const verify2Fa = (options: Options<Verify2FaData>) => { return (options?.client ?? client).post<Verify2FaResponse, Verify2FaError>({
    ...options,
    url: '/auth/twofactorauth/totp/verify'
}); };

/**
 * Verify 2FA code with Recovery code
 * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
 */
export const verifyRecoveryCode = (options: Options<VerifyRecoveryCodeData>) => { return (options?.client ?? client).post<VerifyRecoveryCodeResponse, VerifyRecoveryCodeError>({
    ...options,
    url: '/auth/twofactorauth/otp/verify'
}); };

/**
 * Verify 2FA email code
 * Finishes the login sequence with an 2FA email code.
 */
export const verify2FaEmailCode = (options: Options<Verify2FaEmailCodeData>) => { return (options?.client ?? client).post<Verify2FaEmailCodeResponse, Verify2FaEmailCodeError>({
    ...options,
    url: '/auth/twofactorauth/emailotp/verify'
}); };

/**
 * Verify Auth Token
 * Verify whether the currently provided Auth Token is valid.
 */
export const verifyAuthToken = (options?: Options) => { return (options?.client ?? client).get<VerifyAuthTokenResponse, VerifyAuthTokenError>({
    ...options,
    url: '/auth'
}); };

/**
 * Logout
 * Invalidates the login session.
 */
export const logout = (options?: Options) => { return (options?.client ?? client).put<LogoutResponse, LogoutError>({
    ...options,
    url: '/logout'
}); };

/**
 * Delete User
 * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.
 *
 * **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.
 *
 * **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
 */
export const deleteUser = (options: Options<DeleteUserData>) => { return (options?.client ?? client).put<DeleteUserResponse, DeleteUserError>({
    ...options,
    url: '/users/{userId}/delete'
}); };

/**
 * Get Own Avatar
 * Get the current avatar for the user. This will return an error for any other user than the one logged in.
 */
export const getOwnAvatar = (options: Options<GetOwnAvatarData>) => { return (options?.client ?? client).get<GetOwnAvatarResponse, GetOwnAvatarError>({
    ...options,
    url: '/users/{userId}/avatar'
}); };

/**
 * Search Avatars
 * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
 */
export const searchAvatars = (options?: Options<SearchAvatarsData>) => { return (options?.client ?? client).get<SearchAvatarsResponse, SearchAvatarsError>({
    ...options,
    url: '/avatars'
}); };

/**
 * Create Avatar
 * Create an avatar. It's possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
 */
export const createAvatar = (options?: Options<CreateAvatarData>) => { return (options?.client ?? client).post<CreateAvatarResponse, CreateAvatarError>({
    ...options,
    url: '/avatars'
}); };

/**
 * Get Avatar
 * Get information about a specific Avatar.
 */
export const getAvatar = (options: Options<GetAvatarData>) => { return (options?.client ?? client).get<GetAvatarResponse, GetAvatarError>({
    ...options,
    url: '/avatars/{avatarId}'
}); };

/**
 * Update Avatar
 * Update information about a specific avatar.
 */
export const updateAvatar = (options: Options<UpdateAvatarData>) => { return (options?.client ?? client).put<UpdateAvatarResponse, UpdateAvatarError>({
    ...options,
    url: '/avatars/{avatarId}'
}); };

/**
 * Delete Avatar
 * Delete an avatar. Notice an avatar is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The AvatarID is permanently reserved.
 */
export const deleteAvatar = (options: Options<DeleteAvatarData>) => { return (options?.client ?? client).delete<DeleteAvatarResponse, DeleteAvatarError>({
    ...options,
    url: '/avatars/{avatarId}'
}); };

/**
 * Select Avatar
 * Switches into that avatar.
 */
export const selectAvatar = (options: Options<SelectAvatarData>) => { return (options?.client ?? client).put<SelectAvatarResponse, SelectAvatarError>({
    ...options,
    url: '/avatars/{avatarId}/select'
}); };

/**
 * Select Fallback Avatar
 * Switches into that avatar as your fallback avatar.
 */
export const selectFallbackAvatar = (options: Options<SelectFallbackAvatarData>) => { return (options?.client ?? client).put<SelectFallbackAvatarResponse, SelectFallbackAvatarError>({
    ...options,
    url: '/avatars/{avatarId}/selectFallback'
}); };

/**
 * List Favorited Avatars
 * Search and list favorited avatars by query filters.
 */
export const getFavoritedAvatars = (options?: Options<GetFavoritedAvatarsData>) => { return (options?.client ?? client).get<GetFavoritedAvatarsResponse, GetFavoritedAvatarsError>({
    ...options,
    url: '/avatars/favorites'
}); };

/**
 * List Steam Transactions
 * Get all own Steam transactions.
 */
export const getSteamTransactions = (options?: Options) => { return (options?.client ?? client).get<GetSteamTransactionsResponse, GetSteamTransactionsError>({
    ...options,
    url: '/Steam/transactions'
}); };

/**
 * @deprecated
 * Get Steam Transaction
 * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
 */
export const getSteamTransaction = (options: Options<GetSteamTransactionData>) => { return (options?.client ?? client).get<GetSteamTransactionResponse, GetSteamTransactionError>({
    ...options,
    url: '/Steam/transactions/{transactionId}'
}); };

/**
 * Get Current Subscriptions
 * Get a list of all current user subscriptions.
 */
export const getCurrentSubscriptions = (options?: Options) => { return (options?.client ?? client).get<GetCurrentSubscriptionsResponse, GetCurrentSubscriptionsError>({
    ...options,
    url: '/auth/user/subscription'
}); };

/**
 * List Subscriptions
 * List all existing Subscriptions. For example, "vrchatplus-monthly" and "vrchatplus-yearly".
 */
export const getSubscriptions = (options?: Options) => { return (options?.client ?? client).get<GetSubscriptionsResponse, GetSubscriptionsError>({
    ...options,
    url: '/subscriptions'
}); };

/**
 * Get License Group
 * Get a single License Group by given ID.
 */
export const getLicenseGroup = (options: Options<GetLicenseGroupData>) => { return (options?.client ?? client).get<GetLicenseGroupResponse, GetLicenseGroupError>({
    ...options,
    url: '/licenseGroups/{licenseGroupId}'
}); };

/**
 * List Favorites
 * Returns a list of favorites.
 */
export const getFavorites = (options?: Options<GetFavoritesData>) => { return (options?.client ?? client).get<GetFavoritesResponse, GetFavoritesError>({
    ...options,
    url: '/favorites'
}); };

/**
 * Add Favorite
 * Add a new favorite.
 *
 * Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.
 *
 * You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
 */
export const addFavorite = (options?: Options<AddFavoriteData>) => { return (options?.client ?? client).post<AddFavoriteResponse, AddFavoriteError>({
    ...options,
    url: '/favorites'
}); };

/**
 * Show Favorite
 * Return information about a specific Favorite.
 */
export const getFavorite = (options: Options<GetFavoriteData>) => { return (options?.client ?? client).get<GetFavoriteResponse, GetFavoriteError>({
    ...options,
    url: '/favorites/{favoriteId}'
}); };

/**
 * Remove Favorite
 * Remove a favorite from your favorites list.
 */
export const removeFavorite = (options: Options<RemoveFavoriteData>) => { return (options?.client ?? client).delete<RemoveFavoriteResponse, RemoveFavoriteError>({
    ...options,
    url: '/favorites/{favoriteId}'
}); };

/**
 * List Favorite Groups
 * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
 */
export const getFavoriteGroups = (options?: Options<GetFavoriteGroupsData>) => { return (options?.client ?? client).get<GetFavoriteGroupsResponse, GetFavoriteGroupsError>({
    ...options,
    url: '/favorite/groups'
}); };

/**
 * Show Favorite Group
 * Fetch information about a specific favorite group.
 */
export const getFavoriteGroup = (options: Options<GetFavoriteGroupData>) => { return (options?.client ?? client).get<GetFavoriteGroupResponse, GetFavoriteGroupError>({
    ...options,
    url: '/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}'
}); };

/**
 * Update Favorite Group
 * Update information about a specific favorite group.
 */
export const updateFavoriteGroup = (options: Options<UpdateFavoriteGroupData>) => { return (options?.client ?? client).put<UpdateFavoriteGroupResponse, UpdateFavoriteGroupError>({
    ...options,
    url: '/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}'
}); };

/**
 * Clear Favorite Group
 * Clear ALL contents of a specific favorite group.
 */
export const clearFavoriteGroup = (options: Options<ClearFavoriteGroupData>) => { return (options?.client ?? client).delete<ClearFavoriteGroupResponse, ClearFavoriteGroupError>({
    ...options,
    url: '/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}'
}); };

/**
 * List Files
 * Returns a list of files
 */
export const getFiles = (options?: Options<GetFilesData>) => { return (options?.client ?? client).get<GetFilesResponse, GetFilesError>({
    ...options,
    url: '/files'
}); };

/**
 * Create File
 * Creates a new File object
 */
export const createFile = (options?: Options<CreateFileData>) => { return (options?.client ?? client).post<CreateFileResponse, CreateFileError>({
    ...options,
    url: '/file'
}); };

/**
 * Show File
 * Shows general information about the "File" object. Each File can have several "Version"'s, and each Version can have multiple real files or "Data" blobs.
 */
export const getFile = (options: Options<GetFileData>) => { return (options?.client ?? client).get<GetFileResponse, GetFileError>({
    ...options,
    url: '/file/{fileId}'
}); };

/**
 * Delete File
 * Deletes a File object.
 */
export const deleteFile = (options: Options<DeleteFileData>) => { return (options?.client ?? client).delete<DeleteFileResponse, DeleteFileError>({
    ...options,
    url: '/file/{fileId}'
}); };

/**
 * Create File Version
 * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
 */
export const createFileVersion = (options: Options<CreateFileVersionData>) => { return (options?.client ?? client).post<CreateFileVersionResponse, CreateFileVersionError>({
    ...options,
    url: '/file/{fileId}'
}); };

/**
 * Download File Version
 * Downloads the file with the provided version number.
 *
 * **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.
 *
 * **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
 */
export const downloadFileVersion = (options: Options<DownloadFileVersionData>) => { return (options?.client ?? client).get<DownloadFileVersionResponse, DownloadFileVersionError>({
    ...options,
    url: '/file/{fileId}/{versionId}'
}); };

/**
 * Delete File Version
 * Delete a specific version of a file. You can only delete the latest version.
 */
export const deleteFileVersion = (options: Options<DeleteFileVersionData>) => { return (options?.client ?? client).delete<DeleteFileVersionResponse, DeleteFileVersionError>({
    ...options,
    url: '/file/{fileId}/{versionId}'
}); };

/**
 * Finish FileData Upload
 * Finish an upload of a FileData. This will mark it as "complete". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
 */
export const finishFileDataUpload = (options: Options<FinishFileDataUploadData>) => { return (options?.client ?? client).put<FinishFileDataUploadResponse, FinishFileDataUploadError>({
    ...options,
    url: '/file/{fileId}/{versionId}/{fileType}/finish'
}); };

/**
 * Start FileData Upload
 * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS's REST documentation on "PUT Object to S3" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.
 *
 * **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
 */
export const startFileDataUpload = (options: Options<StartFileDataUploadData>) => { return (options?.client ?? client).put<StartFileDataUploadResponse, StartFileDataUploadError>({
    ...options,
    url: '/file/{fileId}/{versionId}/{fileType}/start'
}); };

/**
 * Check FileData Upload Status
 * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
 */
export const getFileDataUploadStatus = (options: Options<GetFileDataUploadStatusData>) => { return (options?.client ?? client).get<GetFileDataUploadStatusResponse, GetFileDataUploadStatusError>({
    ...options,
    url: '/file/{fileId}/{versionId}/{fileType}/status'
}); };

/**
 * List Friends
 * List information about friends.
 */
export const getFriends = (options?: Options<GetFriendsData>) => { return (options?.client ?? client).get<GetFriendsResponse, GetFriendsError>({
    ...options,
    url: '/auth/user/friends'
}); };

/**
 * Send Friend Request
 * Send a friend request to another user.
 */
export const friend = (options: Options<FriendData>) => { return (options?.client ?? client).post<FriendResponse, FriendError>({
    ...options,
    url: '/user/{userId}/friendRequest'
}); };

/**
 * Delete Friend Request
 * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
 */
export const deleteFriendRequest = (options: Options<DeleteFriendRequestData>) => { return (options?.client ?? client).delete<DeleteFriendRequestResponse, DeleteFriendRequestError>({
    ...options,
    url: '/user/{userId}/friendRequest'
}); };

/**
 * Check Friend Status
 * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
 */
export const getFriendStatus = (options: Options<GetFriendStatusData>) => { return (options?.client ?? client).get<GetFriendStatusResponse, GetFriendStatusError>({
    ...options,
    url: '/user/{userId}/friendStatus'
}); };

/**
 * Unfriend
 * Unfriend a user by ID.
 */
export const unfriend = (options: Options<UnfriendData>) => { return (options?.client ?? client).delete<UnfriendResponse, UnfriendError>({
    ...options,
    url: '/auth/user/friends/{userId}'
}); };

/**
 * Search Group
 * Searches Groups by name or shortCode
 */
export const searchGroups = (options?: Options<SearchGroupsData>) => { return (options?.client ?? client).get<SearchGroupsResponse, SearchGroupsError>({
    ...options,
    url: '/groups'
}); };

/**
 * Create Group
 * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
 */
export const createGroup = (options: Options<CreateGroupData>) => { return (options?.client ?? client).post<CreateGroupResponse, CreateGroupError>({
    ...options,
    url: '/groups'
}); };

/**
 * Get Group by ID
 * Returns a single Group by ID.
 */
export const getGroup = (options: Options<GetGroupData>) => { return (options?.client ?? client).get<GetGroupResponse, GetGroupError>({
    ...options,
    url: '/groups/{groupId}'
}); };

/**
 * Update Group
 * Updates a Group and returns it.
 */
export const updateGroup = (options: Options<UpdateGroupData>) => { return (options?.client ?? client).put<UpdateGroupResponse, UpdateGroupError>({
    ...options,
    url: '/groups/{groupId}'
}); };

/**
 * Delete Group
 * Deletes a Group.
 */
export const deleteGroup = (options: Options<DeleteGroupData>) => { return (options?.client ?? client).delete<DeleteGroupResponse, DeleteGroupError>({
    ...options,
    url: '/groups/{groupId}'
}); };

/**
 * Get Group Announcement
 * Returns the announcement for a Group.
 * If no announcement has been made, then it returns **empty object**.
 * If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
 */
export const getGroupAnnouncements = (options: Options<GetGroupAnnouncementsData>) => { return (options?.client ?? client).get<GetGroupAnnouncementsResponse, GetGroupAnnouncementsError>({
    ...options,
    url: '/groups/{groupId}/announcement'
}); };

/**
 * Create Group Announcement
 * Creates an Announcement for a Group.
 */
export const createGroupAnnouncement = (options: Options<CreateGroupAnnouncementData>) => { return (options?.client ?? client).post<CreateGroupAnnouncementResponse, CreateGroupAnnouncementError>({
    ...options,
    url: '/groups/{groupId}/announcement'
}); };

/**
 * Delete Group Announcement
 * Deletes the announcement for a Group.
 */
export const deleteGroupAnnouncement = (options: Options<DeleteGroupAnnouncementData>) => { return (options?.client ?? client).delete<DeleteGroupAnnouncementResponse, DeleteGroupAnnouncementError>({
    ...options,
    url: '/groups/{groupId}/announcement'
}); };

/**
 * Get Group Audit Logs
 * Returns a list of audit logs for a Group.
 */
export const getGroupAuditLogs = (options: Options<GetGroupAuditLogsData>) => { return (options?.client ?? client).get<GetGroupAuditLogsResponse, GetGroupAuditLogsError>({
    ...options,
    url: '/groups/{groupId}/auditLogs'
}); };

/**
 * Get Group Bans
 * Returns a list of banned users for a Group.
 */
export const getGroupBans = (options: Options<GetGroupBansData>) => { return (options?.client ?? client).get<GetGroupBansResponse, GetGroupBansError>({
    ...options,
    url: '/groups/{groupId}/bans'
}); };

/**
 * Ban Group Member
 * Bans a user from a Group.
 */
export const banGroupMember = (options: Options<BanGroupMemberData>) => { return (options?.client ?? client).post<BanGroupMemberResponse, BanGroupMemberError>({
    ...options,
    url: '/groups/{groupId}/bans'
}); };

/**
 * Unban Group Member
 * Unbans a user from a Group.
 */
export const unbanGroupMember = (options: Options<UnbanGroupMemberData>) => { return (options?.client ?? client).delete<UnbanGroupMemberResponse, UnbanGroupMemberError>({
    ...options,
    url: '/groups/{groupId}/bans/{userId}'
}); };

/**
 * Create Group Gallery
 * Creates a gallery for a Group.
 */
export const createGroupGallery = (options: Options<CreateGroupGalleryData>) => { return (options?.client ?? client).post<CreateGroupGalleryResponse, CreateGroupGalleryError>({
    ...options,
    url: '/groups/{groupId}/galleries'
}); };

/**
 * Get Group Gallery Images
 * Returns a list of images for a Group gallery.
 */
export const getGroupGalleryImages = (options: Options<GetGroupGalleryImagesData>) => { return (options?.client ?? client).get<GetGroupGalleryImagesResponse, GetGroupGalleryImagesError>({
    ...options,
    url: '/groups/{groupId}/galleries/{groupGalleryId}'
}); };

/**
 * Update Group Gallery
 * Updates a gallery for a Group.
 */
export const updateGroupGallery = (options: Options<UpdateGroupGalleryData>) => { return (options?.client ?? client).put<UpdateGroupGalleryResponse, UpdateGroupGalleryError>({
    ...options,
    url: '/groups/{groupId}/galleries/{groupGalleryId}'
}); };

/**
 * Delete Group Gallery
 * Deletes a gallery for a Group.
 */
export const deleteGroupGallery = (options: Options<DeleteGroupGalleryData>) => { return (options?.client ?? client).delete<DeleteGroupGalleryResponse, DeleteGroupGalleryError>({
    ...options,
    url: '/groups/{groupId}/galleries/{groupGalleryId}'
}); };

/**
 * Add Group Gallery Image
 * Adds an image to a Group gallery.
 */
export const addGroupGalleryImage = (options: Options<AddGroupGalleryImageData>) => { return (options?.client ?? client).post<AddGroupGalleryImageResponse, AddGroupGalleryImageError>({
    ...options,
    url: '/groups/{groupId}/galleries/{groupGalleryId}/images'
}); };

/**
 * Delete Group Gallery Image
 * Deletes an image from a Group gallery.
 */
export const deleteGroupGalleryImage = (options: Options<DeleteGroupGalleryImageData>) => { return (options?.client ?? client).delete<DeleteGroupGalleryImageResponse, DeleteGroupGalleryImageError>({
    ...options,
    url: '/groups/{groupId}/galleries/{groupGalleryId}/images/{groupGalleryImageId}'
}); };

/**
 * Get Group Instances
 * Returns a list of group instances
 */
export const getGroupInstances = (options: Options<GetGroupInstancesData>) => { return (options?.client ?? client).get<GetGroupInstancesResponse, GetGroupInstancesError>({
    ...options,
    url: '/groups/{groupId}/instances'
}); };

/**
 * Get Group Invites Sent
 * Returns a list of members that have been invited to the Group.
 */
export const getGroupInvites = (options: Options<GetGroupInvitesData>) => { return (options?.client ?? client).get<GetGroupInvitesResponse, GetGroupInvitesError>({
    ...options,
    url: '/groups/{groupId}/invites'
}); };

/**
 * Invite User to Group
 * Sends an invite to a user to join the group.
 */
export const createGroupInvite = (options: Options<CreateGroupInviteData>) => { return (options?.client ?? client).post<CreateGroupInviteResponse, CreateGroupInviteError>({
    ...options,
    url: '/groups/{groupId}/invites'
}); };

/**
 * Delete User Invite
 * Deletes an Group invite sent to a User
 */
export const deleteGroupInvite = (options: Options<DeleteGroupInviteData>) => { return (options?.client ?? client).delete<DeleteGroupInviteResponse, DeleteGroupInviteError>({
    ...options,
    url: '/groups/{groupId}/invites/{userId}'
}); };

/**
 * Join Group
 * Join a Group by ID and returns the member object.
 */
export const joinGroup = (options: Options<JoinGroupData>) => { return (options?.client ?? client).post<JoinGroupResponse, JoinGroupError>({
    ...options,
    url: '/groups/{groupId}/join'
}); };

/**
 * Leave Group
 * Leave a group by ID.
 */
export const leaveGroup = (options: Options<LeaveGroupData>) => { return (options?.client ?? client).post<LeaveGroupResponse, LeaveGroupError>({
    ...options,
    url: '/groups/{groupId}/leave'
}); };

/**
 * List Group Members
 * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint.
 * Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
 */
export const getGroupMembers = (options: Options<GetGroupMembersData>) => { return (options?.client ?? client).get<GetGroupMembersResponse, GetGroupMembersError>({
    ...options,
    url: '/groups/{groupId}/members'
}); };

/**
 * Get Group Member
 * Returns a LimitedGroup Member.
 */
export const getGroupMember = (options: Options<GetGroupMemberData>) => { return (options?.client ?? client).get<GetGroupMemberResponse, GetGroupMemberError>({
    ...options,
    url: '/groups/{groupId}/members/{userId}'
}); };

/**
 * Update Group Member
 * Updates a Group Member
 */
export const updateGroupMember = (options: Options<UpdateGroupMemberData>) => { return (options?.client ?? client).put<UpdateGroupMemberResponse, UpdateGroupMemberError>({
    ...options,
    url: '/groups/{groupId}/members/{userId}'
}); };

/**
 * Kick Group Member
 * Kicks a Group Member from the Group. The current user must have the "Remove Group Members" permission.
 */
export const kickGroupMember = (options: Options<KickGroupMemberData>) => { return (options?.client ?? client).delete<KickGroupMemberResponse, KickGroupMemberError>({
    ...options,
    url: '/groups/{groupId}/members/{userId}'
}); };

/**
 * Add Role to GroupMember
 * Adds a Role to a Group Member
 */
export const addGroupMemberRole = (options: Options<AddGroupMemberRoleData>) => { return (options?.client ?? client).put<AddGroupMemberRoleResponse, AddGroupMemberRoleError>({
    ...options,
    url: '/groups/{groupId}/members/{userId}/roles/{groupRoleId}'
}); };

/**
 * Remove Role from GroupMember
 * Removes a Role from a Group Member
 */
export const removeGroupMemberRole = (options: Options<RemoveGroupMemberRoleData>) => { return (options?.client ?? client).delete<RemoveGroupMemberRoleResponse, RemoveGroupMemberRoleError>({
    ...options,
    url: '/groups/{groupId}/members/{userId}/roles/{groupRoleId}'
}); };

/**
 * List Group Permissions
 * Returns a List of all possible/available permissions for a Group.
 */
export const getGroupPermissions = (options: Options<GetGroupPermissionsData>) => { return (options?.client ?? client).get<GetGroupPermissionsResponse, GetGroupPermissionsError>({
    ...options,
    url: '/groups/{groupId}/permissions'
}); };

/**
 * Get posts from a Group
 * Get posts from a Group
 */
export const getGroupPost = (options: Options<GetGroupPostData>) => { return (options?.client ?? client).get<GetGroupPostResponse, GetGroupPostError>({
    ...options,
    url: '/groups/{groupId}/posts'
}); };

/**
 * Create a post in a Group
 * Create a post in a Group.
 */
export const addGroupPost = (options: Options<AddGroupPostData>) => { return (options?.client ?? client).post<AddGroupPostResponse, AddGroupPostError>({
    ...options,
    url: '/groups/{groupId}/posts'
}); };

/**
 * Delete a Group post
 * Delete a Group post
 */
export const deleteGroupPost = (options: Options<DeleteGroupPostData>) => { return (options?.client ?? client).delete<DeleteGroupPostResponse, DeleteGroupPostError>({
    ...options,
    url: '/groups/{groupId}/posts/{notificationId}'
}); };

/**
 * Edits a Group post
 * Edits a Group post
 */
export const updateGroupPost = (options: Options<UpdateGroupPostData>) => { return (options?.client ?? client).put<UpdateGroupPostResponse, UpdateGroupPostError>({
    ...options,
    url: '/groups/{groupId}/posts/{notificationId}'
}); };

/**
 * Get Group Join Requests
 * Returns a list of members that have requested to join the Group.
 */
export const getGroupRequests = (options: Options<GetGroupRequestsData>) => { return (options?.client ?? client).get<GetGroupRequestsResponse, GetGroupRequestsError>({
    ...options,
    url: '/groups/{groupId}/requests'
}); };

/**
 * Cancel Group Join Request
 * Cancels a request sent to join the group.
 */
export const cancelGroupRequest = (options: Options<CancelGroupRequestData>) => { return (options?.client ?? client).delete<CancelGroupRequestResponse, CancelGroupRequestError>({
    ...options,
    url: '/groups/{groupId}/requests'
}); };

/**
 * Respond Group Join request
 * Responds to a Group Join Request with Accept/Deny
 */
export const respondGroupJoinRequest = (options: Options<RespondGroupJoinRequestData>) => { return (options?.client ?? client).put<RespondGroupJoinRequestResponse, RespondGroupJoinRequestError>({
    ...options,
    url: '/groups/{groupId}/requests/{userId}'
}); };

/**
 * Get Group Roles
 * Returns a Group Role by ID.
 */
export const getGroupRoles = (options: Options<GetGroupRolesData>) => { return (options?.client ?? client).get<GetGroupRolesResponse, GetGroupRolesError>({
    ...options,
    url: '/groups/{groupId}/roles'
}); };

/**
 * Create GroupRole
 * Create a Group role.
 */
export const createGroupRole = (options: Options<CreateGroupRoleData>) => { return (options?.client ?? client).post<CreateGroupRoleResponse, CreateGroupRoleError>({
    ...options,
    url: '/groups/{groupId}/roles'
}); };

/**
 * Update Group Role
 * Updates a group role by ID.
 */
export const updateGroupRole = (options: Options<UpdateGroupRoleData>) => { return (options?.client ?? client).put<UpdateGroupRoleResponse, UpdateGroupRoleError>({
    ...options,
    url: '/groups/{groupId}/roles/{groupRoleId}'
}); };

/**
 * Delete Group Role
 * Deletes a Group Role by ID and returns the remaining roles.
 */
export const deleteGroupRole = (options: Options<DeleteGroupRoleData>) => { return (options?.client ?? client).delete<DeleteGroupRoleResponse, DeleteGroupRoleError>({
    ...options,
    url: '/groups/{groupId}/roles/{groupRoleId}'
}); };

/**
 * Invite User
 * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
 */
export const inviteUser = (options: Options<InviteUserData>) => { return (options?.client ?? client).post<InviteUserResponse, InviteUserError>({
    ...options,
    url: '/invite/{userId}'
}); };

/**
 * Invite Myself To Instance
 * Sends self an invite to an instance
 */
export const inviteMyselfTo = (options: Options<InviteMyselfToData>) => { return (options?.client ?? client).post<InviteMyselfToResponse, InviteMyselfToError>({
    ...options,
    url: '/invite/myself/to/{worldId}:{instanceId}'
}); };

/**
 * Request Invite
 * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
 */
export const requestInvite = (options: Options<RequestInviteData>) => { return (options?.client ?? client).post<RequestInviteResponse, RequestInviteError>({
    ...options,
    url: '/requestInvite/{userId}'
}); };

/**
 * Respond Invite
 * Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
 */
export const respondInvite = (options: Options<RespondInviteData>) => { return (options?.client ?? client).post<RespondInviteResponse, RespondInviteError>({
    ...options,
    url: '/invite/{notificationId}/response'
}); };

/**
 * List Invite Messages
 * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!
 *
 * Message type refers to a different collection of messages, used during different types of responses.
 *
 * * `message` = Message during a normal invite
 * * `response` = Message when replying to a message
 * * `request` = Message when requesting an invite
 * * `requestResponse` = Message when replying to a request for invite
 */
export const getInviteMessages = (options: Options<GetInviteMessagesData>) => { return (options?.client ?? client).get<GetInviteMessagesResponse, GetInviteMessagesError>({
    ...options,
    url: '/message/{userId}/{messageType}'
}); };

/**
 * Get Invite Message
 * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!
 *
 * Message type refers to a different collection of messages, used during different types of responses.
 *
 * * `message` = Message during a normal invite
 * * `response` = Message when replying to a message
 * * `request` = Message when requesting an invite
 * * `requestResponse` = Message when replying to a request for invite
 */
export const getInviteMessage = (options: Options<GetInviteMessageData>) => { return (options?.client ?? client).get<GetInviteMessageResponse, GetInviteMessageError>({
    ...options,
    url: '/message/{userId}/{messageType}/{slot}'
}); };

/**
 * Update Invite Message
 * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!
 *
 * Updating a message automatically sets the cooldown timer to 60 minutes.
 * Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
 *
 * Message type refers to a different collection of messages, used during different types of responses.
 *
 * * `message` = Message during a normal invite
 * * `response` = Message when replying to a message
 * * `request` = Message when requesting an invite
 * * `requestResponse` = Message when replying to a request for invite
 */
export const updateInviteMessage = (options: Options<UpdateInviteMessageData>) => { return (options?.client ?? client).put<UpdateInviteMessageResponse, UpdateInviteMessageError>({
    ...options,
    url: '/message/{userId}/{messageType}/{slot}'
}); };

/**
 * Reset Invite Message
 * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!
 *
 * Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown.
 * Resetting it does however not set the rate-limit to 60 like when editing it.
 * It is possible to edit it right after resetting it.
 * Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
 *
 * Message type refers to a different collection of messages, used during different types of responses.
 *
 * * `message` = Message during a normal invite
 * * `response` = Message when replying to a message
 * * `request` = Message when requesting an invite
 * * `requestResponse` = Message when replying to a request for invite
 *
 * The DELETE endpoint does not have/require any request body.
 */
export const resetInviteMessage = (options: Options<ResetInviteMessageData>) => { return (options?.client ?? client).delete<ResetInviteMessageResponse, ResetInviteMessageError>({
    ...options,
    url: '/message/{userId}/{messageType}/{slot}'
}); };

/**
 * Create Instance
 * Create an instance
 */
export const createInstance = (options: Options<CreateInstanceData>) => { return (options?.client ?? client).post<CreateInstanceResponse, CreateInstanceError>({
    ...options,
    url: '/instances'
}); };

/**
 * Get Instance
 * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
 *
 * If an invalid instanceId is provided, this endpoint will simply return "null"!
 */
export const getInstance = (options: Options<GetInstanceData>) => { return (options?.client ?? client).get<GetInstanceResponse, GetInstanceError>({
    ...options,
    url: '/instances/{worldId}:{instanceId}'
}); };

/**
 * Close Instance
 * Close an instance or update the closedAt time when it will be closed.
 *
 * You can only close an instance if the ownerId is yourself or if the instance owner is a group and you have the `group-instance-moderate` permission.
 */
export const closeInstance = (options: Options<CloseInstanceData>) => { return (options?.client ?? client).delete<CloseInstanceResponse, CloseInstanceError>({
    ...options,
    url: '/instances/{worldId}:{instanceId}'
}); };

/**
 * Get Instance Short Name
 * Returns an instance short name.
 */
export const getShortName = (options: Options<GetShortNameData>) => { return (options?.client ?? client).get<GetShortNameResponse, GetShortNameError>({
    ...options,
    url: '/instances/{worldId}:{instanceId}/shortName'
}); };

/**
 * Send Self Invite
 * Sends an invite to the instance to yourself.
 */
export const sendSelfInvite = (options: Options<SendSelfInviteData>) => { return (options?.client ?? client).post<SendSelfInviteResponse, SendSelfInviteError>({
    ...options,
    url: '/instances/{worldId}:{instanceId}/invite'
}); };

/**
 * Get Instance By Short Name
 * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
 */
export const getInstanceByShortName = (options: Options<GetInstanceByShortNameData>) => { return (options?.client ?? client).get<GetInstanceByShortNameResponse, GetInstanceByShortNameError>({
    ...options,
    url: '/instances/s/{shortName}'
}); };

/**
 * List Notifications
 * Retrieve all of the current user's notifications.
 */
export const getNotifications = (options?: Options<GetNotificationsData>) => { return (options?.client ?? client).get<GetNotificationsResponse, GetNotificationsError>({
    ...options,
    url: '/auth/user/notifications'
}); };

/**
 * Accept Friend Request
 * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
 */
export const acceptFriendRequest = (options: Options<AcceptFriendRequestData>) => { return (options?.client ?? client).put<AcceptFriendRequestResponse, AcceptFriendRequestError>({
    ...options,
    url: '/auth/user/notifications/{notificationId}/accept'
}); };

/**
 * Mark Notification As Read
 * Mark a notification as seen.
 */
export const markNotificationAsRead = (options: Options<MarkNotificationAsReadData>) => { return (options?.client ?? client).put<MarkNotificationAsReadResponse, MarkNotificationAsReadError>({
    ...options,
    url: '/auth/user/notifications/{notificationId}/see'
}); };

/**
 * Delete Notification
 * Delete a notification.
 */
export const deleteNotification = (options: Options<DeleteNotificationData>) => { return (options?.client ?? client).put<DeleteNotificationResponse, DeleteNotificationError>({
    ...options,
    url: '/auth/user/notifications/{notificationId}/hide'
}); };

/**
 * Clear All Notifications
 * Clear **all** notifications.
 */
export const clearNotifications = (options?: Options) => { return (options?.client ?? client).put<ClearNotificationsResponse, ClearNotificationsError>({
    ...options,
    url: '/auth/user/notifications/clear'
}); };

/**
 * Get Assigned Permissions
 * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
 */
export const getAssignedPermissions = (options?: Options) => { return (options?.client ?? client).get<GetAssignedPermissionsResponse, GetAssignedPermissionsError>({
    ...options,
    url: '/auth/permissions'
}); };

/**
 * Get Permission
 * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
 */
export const getPermission = (options: Options<GetPermissionData>) => { return (options?.client ?? client).get<GetPermissionResponse, GetPermissionError>({
    ...options,
    url: '/permissions/{permissionId}'
}); };

/**
 * Search Player Moderations
 * Returns a list of all player moderations made by **you**.
 *
 * This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
 */
export const getPlayerModerations = (options?: Options<GetPlayerModerationsData>) => { return (options?.client ?? client).get<GetPlayerModerationsResponse, GetPlayerModerationsError>({
    ...options,
    url: '/auth/user/playermoderations'
}); };

/**
 * Moderate User
 * Moderate a user, e.g. unmute them or show their avatar.
 *
 * Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
 */
export const moderateUser = (options: Options<ModerateUserData>) => { return (options?.client ?? client).post<ModerateUserResponse, ModerateUserError>({
    ...options,
    url: '/auth/user/playermoderations'
}); };

/**
 * Clear All Player Moderations
 *  **This will delete every single player moderation you've ever made.**
 */
export const clearAllPlayerModerations = (options?: Options) => { return (options?.client ?? client).delete<ClearAllPlayerModerationsResponse, ClearAllPlayerModerationsError>({
    ...options,
    url: '/auth/user/playermoderations'
}); };

/**
 * Get Player Moderation
 * Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
 */
export const getPlayerModeration = (options: Options<GetPlayerModerationData>) => { return (options?.client ?? client).get<GetPlayerModerationResponse, GetPlayerModerationError>({
    ...options,
    url: '/auth/user/playermoderations/{playerModerationId}'
}); };

/**
 * Delete Player Moderation
 * Deletes a specific player moderation based on it's `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
 */
export const deletePlayerModeration = (options: Options<DeletePlayerModerationData>) => { return (options?.client ?? client).delete<DeletePlayerModerationResponse, DeletePlayerModerationError>({
    ...options,
    url: '/auth/user/playermoderations/{playerModerationId}'
}); };

/**
 * Unmoderate User
 * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
 */
export const unmoderateUser = (options: Options<UnmoderateUserData>) => { return (options?.client ?? client).put<UnmoderateUserResponse, UnmoderateUserError>({
    ...options,
    url: '/auth/user/unplayermoderate'
}); };

/**
 * Fetch API Config
 * API config contains configuration that the clients needs to work properly.
 *
 * Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
 */
export const getConfig = (options?: Options) => { return (options?.client ?? client).get<GetConfigResponse, GetConfigError>({
    ...options,
    url: '/config'
}); };

/**
 * Show Information Notices
 * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.
 *
 * `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an "any of" search.
 *
 * `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an "all of" search.
 */
export const getInfoPush = (options?: Options<GetInfoPushData>) => { return (options?.client ?? client).get<GetInfoPushResponse, GetInfoPushError>({
    ...options,
    url: '/infoPush'
}); };

/**
 * Download CSS
 * Fetches the CSS code to the frontend React website.
 */
export const getCss = (options?: Options<GetCssData>) => { return (options?.client ?? client).get<GetCssResponse, GetCssError>({
    ...options,
    url: '/css/app.css'
}); };

/**
 * Download JavaScript
 * Fetches the JavaScript code to the frontend React website.
 */
export const getJavaScript = (options?: Options<GetJavaScriptData>) => { return (options?.client ?? client).get<GetJavaScriptResponse, GetJavaScriptError>({
    ...options,
    url: '/js/app.js'
}); };

/**
 * @deprecated
 * Check API Health
 * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~
 *
 * **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
 */
export const getHealth = (options?: Options) => { return (options?.client ?? client).get<GetHealthResponse, GetHealthError>({
    ...options,
    url: '/health'
}); };

/**
 * Current Online Users
 * Returns the current number of online users.
 *
 * **NOTE:** The response type is not a JSON object, but a simple JSON integer.
 */
export const getCurrentOnlineUsers = (options?: Options) => { return (options?.client ?? client).get<GetCurrentOnlineUsersResponse, GetCurrentOnlineUsersError>({
    ...options,
    url: '/visits'
}); };

/**
 * Current System Time
 * Returns the current time of the API server.
 *
 * **NOTE:** The response type is not a JSON object, but a simple JSON string.
 */
export const getSystemTime = (options?: Options) => { return (options?.client ?? client).get<GetSystemTimeResponse, GetSystemTimeError>({
    ...options,
    url: '/time'
}); };

/**
 * Search All Users
 * Search and list any users by text query
 */
export const searchUsers = (options?: Options<SearchUsersData>) => { return (options?.client ?? client).get<SearchUsersResponse, SearchUsersError>({
    ...options,
    url: '/users'
}); };

/**
 * @deprecated
 * Get User by Username
 * ~~Get public user information about a specific user using their name.~~
 *
 * **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
 * This endpoint now require Admin Credentials.
 */
export const getUserByName = (options: Options<GetUserByNameData>) => { return (options?.client ?? client).get<GetUserByNameResponse, GetUserByNameError>({
    ...options,
    url: '/users/{username}/name'
}); };

/**
 * Get User by ID
 * Get public user information about a specific user using their ID.
 */
export const getUser = (options: Options<GetUserData>) => { return (options?.client ?? client).get<GetUserResponse, GetUserError>({
    ...options,
    url: '/users/{userId}'
}); };

/**
 * Update User Info
 * Update a users information such as the email and birthday.
 */
export const updateUser = (options: Options<UpdateUserData>) => { return (options?.client ?? client).put<UpdateUserResponse, UpdateUserError>({
    ...options,
    url: '/users/{userId}'
}); };

/**
 * Get User Groups
 * Get user's public groups
 */
export const getUserGroups = (options: Options<GetUserGroupsData>) => { return (options?.client ?? client).get<GetUserGroupsResponse, GetUserGroupsError>({
    ...options,
    url: '/users/{userId}/groups'
}); };

/**
 * Get User Group Requests
 * Returns a list of Groups the user has requested to be invited into.
 */
export const getUserGroupRequests = (options: Options<GetUserGroupRequestsData>) => { return (options?.client ?? client).get<GetUserGroupRequestsResponse, GetUserGroupRequestsError>({
    ...options,
    url: '/users/{userId}/groups/requested'
}); };

/**
 * Get user's current represented group
 * Returns the current group that the user is currently representing
 */
export const getUserRepresentedGroup = (options: Options<GetUserRepresentedGroupData>) => { return (options?.client ?? client).get<GetUserRepresentedGroupResponse, GetUserRepresentedGroupError>({
    ...options,
    url: '/users/{userId}/groups/represented'
}); };

/**
 * Search All Worlds
 * Search and list any worlds by query filters.
 */
export const searchWorlds = (options?: Options<SearchWorldsData>) => { return (options?.client ?? client).get<SearchWorldsResponse, SearchWorldsError>({
    ...options,
    url: '/worlds'
}); };

/**
 * Create World
 * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
 */
export const createWorld = (options?: Options<CreateWorldData>) => { return (options?.client ?? client).post<CreateWorldResponse, CreateWorldError>({
    ...options,
    url: '/worlds'
}); };

/**
 * List Active Worlds
 * Search and list currently Active worlds by query filters.
 */
export const getActiveWorlds = (options?: Options<GetActiveWorldsData>) => { return (options?.client ?? client).get<GetActiveWorldsResponse, GetActiveWorldsError>({
    ...options,
    url: '/worlds/active'
}); };

/**
 * List Favorited Worlds
 * Search and list favorited worlds by query filters.
 */
export const getFavoritedWorlds = (options?: Options<GetFavoritedWorldsData>) => { return (options?.client ?? client).get<GetFavoritedWorldsResponse, GetFavoritedWorldsError>({
    ...options,
    url: '/worlds/favorites'
}); };

/**
 * List Recent Worlds
 * Search and list recently visited worlds by query filters.
 */
export const getRecentWorlds = (options?: Options<GetRecentWorldsData>) => { return (options?.client ?? client).get<GetRecentWorldsResponse, GetRecentWorldsError>({
    ...options,
    url: '/worlds/recent'
}); };

/**
 * Get World by ID
 * Get information about a specific World.
 * Works unauthenticated but when so will always return `0` for certain fields.
 */
export const getWorld = (options: Options<GetWorldData>) => { return (options?.client ?? client).get<GetWorldResponse, GetWorldError>({
    ...options,
    url: '/worlds/{worldId}'
}); };

/**
 * Update World
 * Update information about a specific World.
 */
export const updateWorld = (options: Options<UpdateWorldData>) => { return (options?.client ?? client).put<UpdateWorldResponse, UpdateWorldError>({
    ...options,
    url: '/worlds/{worldId}'
}); };

/**
 * Delete World
 * Delete a world. Notice a world is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The WorldID is permanently reserved.
 */
export const deleteWorld = (options: Options<DeleteWorldData>) => { return (options?.client ?? client).delete<DeleteWorldResponse, DeleteWorldError>({
    ...options,
    url: '/worlds/{worldId}'
}); };

/**
 * @deprecated
 * Get World Metadata
 * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
 */
export const getWorldMetadata = (options: Options<GetWorldMetadataData>) => { return (options?.client ?? client).get<GetWorldMetadataResponse, GetWorldMetadataError>({
    ...options,
    url: '/worlds/{worldId}/metadata'
}); };

/**
 * Get World Publish Status
 * Returns a worlds publish status.
 */
export const getWorldPublishStatus = (options: Options<GetWorldPublishStatusData>) => { return (options?.client ?? client).get<GetWorldPublishStatusResponse, GetWorldPublishStatusError>({
    ...options,
    url: '/worlds/{worldId}/publish'
}); };

/**
 * Publish World
 * Publish a world. You can only publish one world per week.
 */
export const publishWorld = (options: Options<PublishWorldData>) => { return (options?.client ?? client).put<PublishWorldResponse, PublishWorldError>({
    ...options,
    url: '/worlds/{worldId}/publish'
}); };

/**
 * Unpublish World
 * Unpublish a world.
 */
export const unpublishWorld = (options: Options<UnpublishWorldData>) => { return (options?.client ?? client).delete<UnpublishWorldResponse, UnpublishWorldError>({
    ...options,
    url: '/worlds/{worldId}/publish'
}); };

/**
 * Get World Instance
 * Returns a worlds instance.
 */
export const getWorldInstance = (options: Options<GetWorldInstanceData>) => { return (options?.client ?? client).get<GetWorldInstanceResponse, GetWorldInstanceError>({
    ...options,
    url: '/worlds/{worldId}/{instanceId}'
}); };